diff --git a/Changelog.md b/Changelog.md
index dcd6caf..8e88880 100644
--- a/Changelog.md
+++ b/Changelog.md
@@ -1,6 +1,10 @@
 ## 13.5250.6
 * DAE autocomplete now exposes only canonical AC5E keys under `flags.automated-conditions-5e.*`.
   * Short aliases like `flags.ac5e.*` remain runtime-compatible for parsing/evaluation, but are no longer suggested in autocomplete.
+* Added `no<Status>` scope support for `source`, `grants`, and `aura` keys.
+  * Status suppression now recognizes `flags.automated-conditions-5e.grants.noProne` and `flags.automated-conditions-5e.aura.noProne` style keys in addition to source-path keys.
+* Status effect overrides can now add tooltip context with override names.
+  * When an override with `name` applies, status labels are shown as `Base Status (Override Name)` (for example `Prone (Ignore Prone in Rage)`).
 
 ## 13.5250.5
 ### New Opt-in Features
diff --git a/scripts/ac5e-helpers.mjs b/scripts/ac5e-helpers.mjs
index 95863c4..9eec41f 100644
--- a/scripts/ac5e-helpers.mjs
+++ b/scripts/ac5e-helpers.mjs
@@ -2707,6 +2707,7 @@ export function _raceOrType(actor, dataType = 'race') {
 
 export function _generateAC5eFlags() {
 	const moduleFlagScope = `flags.${Constants.MODULE_ID}`;
+	const statusFlagKeys = [...new Set([...Object.keys(CONFIG?.DND5E?.conditionTypes ?? {}), 'bloodied'])].map((statusId) => `no${statusId.charAt(0).toUpperCase()}${statusId.slice(1)}`);
 	const moduleFlags = new Set([
 		`${moduleFlagScope}.crossbowExpert`,
 		`${moduleFlagScope}.sharpShooter`,
@@ -2747,6 +2748,11 @@ export function _generateAC5eFlags() {
 		`${moduleFlagScope}.grants.modifyAC`,
 		`${moduleFlagScope}.aura.modifyAC`,
 	]);
+	for (const statusFlagKey of statusFlagKeys) {
+		moduleFlags.add(`${moduleFlagScope}.${statusFlagKey}`);
+		moduleFlags.add(`${moduleFlagScope}.grants.${statusFlagKey}`);
+		moduleFlags.add(`${moduleFlagScope}.aura.${statusFlagKey}`);
+	}
 
 	const allModesActionTypes = ['all', 'attack', 'check', 'concentration', 'damage', 'death', 'initiative', 'save', 'skill', 'tool'];
 	const noDamageNoInitiativeActionTypes = ['all', 'attack', 'check', 'concentration', 'death', 'save', 'skill', 'tool'];
diff --git a/scripts/ac5e-setpieces.mjs b/scripts/ac5e-setpieces.mjs
index eaeec0c..80e98a4 100644
--- a/scripts/ac5e-setpieces.mjs
+++ b/scripts/ac5e-setpieces.mjs
@@ -335,13 +335,13 @@ export function _ac5eChecks({ ac5eConfig, subjectToken, opponentToken }) {
 			const context = buildStatusEffectsContext({ ac5eConfig, subjectToken, opponentToken, exhaustionLvl, type });
 
 			for (const status of actor.statuses) {
-				const suppressedStatus = getSuppressedStatusData(actor, status);
+				const suppressedStatus = getSuppressedStatusData({ actor, statusId: status, type, subjectToken, opponentToken });
 				if (suppressedStatus.suppressed) {
 					ac5eConfig[type].suppressedStatuses ??= [];
 					ac5eConfig[type].suppressedStatuses.push(...suppressedStatus.labels);
 					continue;
 				}
-				const test = getStatusEffectResult({
+				const statusOutcome = getStatusEffectResult({
 					status,
 					statusEntry: tables?.[status],
 					hook: options.hook,
@@ -350,10 +350,11 @@ export function _ac5eChecks({ ac5eConfig, subjectToken, opponentToken }) {
 					exhaustionLvl,
 					isSubjectExhausted,
 				});
+				const test = statusOutcome?.result ?? '';
 
 				if (!test) continue;
 				if (settings.debug) console.log(type, test);
-				const effectName = tables?.[status]?.name;
+				const effectName = withStatusOverrideLabel(tables?.[status]?.name, statusOutcome?.overrideName);
 				if (effectName) {
 					if (test.includes('advantageNames')) ac5eConfig[type][test].add(effectName);
 					else ac5eConfig[type][test].push(effectName);
@@ -682,7 +683,7 @@ function isFrightenedByVisibleSource(ctx) {
 }
 
 function getStatusEffectResult({ status, statusEntry, hook, type, context, exhaustionLvl, isSubjectExhausted }) {
-	if (!statusEntry) return '';
+	if (!statusEntry) return { result: '', overrideName: undefined };
 	if (status === 'exhaustion' && isSubjectExhausted) {
 		const levelRules = statusEntry.rules?.levels?.[exhaustionLvl];
 		const result = evaluateStatusRule(levelRules?.[hook]?.[type], context);
@@ -697,19 +698,31 @@ function evaluateStatusRule(rule, context) {
 	return typeof rule === 'function' ? rule(context) : rule;
 }
 
+function withStatusOverrideLabel(baseName, overrideName) {
+	if (!baseName && !overrideName) return '';
+	const base = String(baseName ?? '').trim();
+	const override = String(overrideName ?? '').trim();
+	if (!override) return base;
+	if (!base) return override;
+	return `${base} (${override})`;
+}
+
 function applyStatusEffectOverrides({ status, hook, type, context, result }) {
-	if (!statusEffectsOverrideState.list.length) return result;
+	if (!statusEffectsOverrideState.list.length) return { result, overrideName: undefined };
 	const matches = statusEffectsOverrideState.list
 		.filter((entry) => matchesStatusEffectOverride(entry, status, hook, type))
 		.sort((a, b) => (a.priority || 0) - (b.priority || 0));
-	if (!matches.length) return result;
+	if (!matches.length) return { result, overrideName: undefined };
 	let nextResult = result;
+	let overrideName;
 	for (const entry of matches) {
 		if (typeof entry.when === 'function') {
 			if (!entry.when({ status, hook, type, context, result: nextResult })) continue;
 		} else if (entry.when === false) {
 			continue;
 		}
+		const namedOverride = typeof entry.name === 'string' ? entry.name.trim() : '';
+		if (namedOverride) overrideName = namedOverride;
 		if (typeof entry.apply === 'function') {
 			const updated = entry.apply({ status, hook, type, context, result: nextResult });
 			if (updated !== undefined) nextResult = updated;
@@ -717,7 +730,7 @@ function applyStatusEffectOverrides({ status, hook, type, context, result }) {
 		}
 		if (entry.result !== undefined) nextResult = entry.result;
 	}
-	return nextResult;
+	return { result: nextResult, overrideName };
 }
 
 function matchesStatusEffectOverride(entry, status, hook, type) {
@@ -746,24 +759,119 @@ function _parseFlagBoolean(value) {
 	return Boolean(value);
 }
 
-function getSuppressedStatusData(actor, statusId) {
+function _parseFlagBooleanStrict(value) {
+	if (value === undefined || value === null) return undefined;
+	if (typeof value === 'boolean') return value;
+	if (typeof value === 'number') return value !== 0;
+	if (typeof value !== 'string') return undefined;
+	const normalized = value.trim().toLowerCase();
+	if (!normalized.length) return undefined;
+	if (['true', '1', 'yes', 'on'].includes(normalized)) return true;
+	if (['false', '0', 'no', 'off'].includes(normalized)) return false;
+	const parts = normalized.split(';').map((part) => part.trim()).filter(Boolean);
+	for (const part of parts) {
+		if (part.includes('=') || part.includes(':')) continue;
+		if (['true', '1', 'yes', 'on'].includes(part)) return true;
+		if (['false', '0', 'no', 'off'].includes(part)) return false;
+	}
+	return undefined;
+}
+
+function _passesFriendOrFoeFilter({ sourceToken, targetToken, rawValue }) {
+	if (typeof rawValue !== 'string') return true;
+	const normalized = rawValue.toLowerCase();
+	const hasAllies = normalized.includes('allies');
+	const hasEnemies = normalized.includes('enemies');
+	if (!hasAllies && !hasEnemies) return true;
+	if (!sourceToken || !targetToken) return true;
+	const sameDisposition = _dispositionCheck(sourceToken, targetToken, 'same');
+	if (hasAllies && !sameDisposition) return false;
+	if (hasEnemies && sameDisposition) return false;
+	return true;
+}
+
+function _evaluateSuppressedStatusFlagValue({ rawValue, scope, targetToken, sourceToken, auraToken }) {
+	if (_parseFlagBooleanStrict(rawValue) !== true) return false;
+	if (scope === 'grants') return _passesFriendOrFoeFilter({ sourceToken, targetToken, rawValue });
+	if (scope !== 'aura') return true;
+	if (!_passesFriendOrFoeFilter({ sourceToken: auraToken ?? sourceToken, targetToken, rawValue })) return false;
+	const normalized = typeof rawValue === 'string' ? rawValue.toLowerCase() : '';
+	if (auraToken?.id && targetToken?.id && auraToken.id === targetToken.id && !normalized.includes('includeself')) return false;
+	if (typeof rawValue !== 'string') return true;
+	const radiusRaw = getBlacklistedKeysValue('radius', rawValue);
+	if (!radiusRaw) return true;
+	const radius = Number(radiusRaw);
+	if (!Number.isFinite(radius)) return false;
+	const wallsBlock = normalized.includes('wallsblock') ? 'sight' : false;
+	const distance = _getDistance(auraToken, targetToken, false, true, wallsBlock, true);
+	return Number.isFinite(distance) && distance <= radius;
+}
+
+function getSuppressedStatusData({ actor, statusId, type, subjectToken, opponentToken }) {
 	if (!actor || !statusId) return { suppressed: false, labels: [] };
-	const flagName = `no${statusId.capitalize()}`;
-	const flagPaths = [`flags.${Constants.MODULE_ID}.${flagName}`, `flags.ac5e.${flagName}`];
-	const moduleValue = foundry.utils.getProperty(actor, flagPaths[0]);
-	const legacyValue = foundry.utils.getProperty(actor, flagPaths[1]);
-	const actorFlagValue = moduleValue !== undefined ? moduleValue : legacyValue;
-	const suppressed = _parseFlagBoolean(actorFlagValue);
-	if (!suppressed) return { suppressed: false, labels: [] };
+	const statusKey = statusId.capitalize();
+	const flagName = `no${statusKey}`;
+	const targetToken = type === 'opponent' ? opponentToken : subjectToken;
+	const relatedToken = type === 'opponent' ? subjectToken : opponentToken;
+	const sourceFlagPaths = [`flags.${Constants.MODULE_ID}.${flagName}`, `flags.ac5e.${flagName}`];
+	const grantsFlagPaths = [`flags.${Constants.MODULE_ID}.grants.${flagName}`, `flags.ac5e.grants.${flagName}`];
+	const auraFlagPaths = [`flags.${Constants.MODULE_ID}.aura.${flagName}`, `flags.ac5e.aura.${flagName}`];
+	const labels = new Set();
+	let suppressed = false;
+
+	const evaluateActorFlags = ({ actorDocument, flagPaths, scope, sourceToken, auraToken }) => {
+		if (!actorDocument) return;
+		for (const path of flagPaths) {
+			const rawValue = foundry.utils.getProperty(actorDocument, path);
+			if (_evaluateSuppressedStatusFlagValue({ rawValue, scope, targetToken, sourceToken, auraToken })) {
+				suppressed = true;
+				return;
+			}
+		}
+	};
 
-	const labels = [];
-	for (const effect of actor.appliedEffects ?? []) {
-		const changes = Array.isArray(effect?.changes) ? effect.changes : [];
-		const hasSuppressingChange = changes.some((change) => flagPaths.includes(change?.key) && _parseFlagBoolean(change?.value));
-		if (hasSuppressingChange && effect?.name) labels.push(`${effect.name} (${flagName})`);
+	const evaluateEffects = ({ effects, flagPaths, scope, sourceToken, auraToken, buildLabel }) => {
+		for (const effect of effects ?? []) {
+			const changes = Array.isArray(effect?.changes) ? effect.changes : [];
+			let matched = false;
+			for (const change of changes) {
+				if (!flagPaths.includes(change?.key)) continue;
+				if (!_evaluateSuppressedStatusFlagValue({ rawValue: change?.value, scope, targetToken, sourceToken, auraToken })) continue;
+				matched = true;
+				break;
+			}
+			if (!matched) continue;
+			suppressed = true;
+			if (!effect?.name) continue;
+			const nextLabel = typeof buildLabel === 'function' ? buildLabel(effect) : `${effect.name} (${flagName})`;
+			if (nextLabel) labels.add(nextLabel);
+		}
+	};
+
+	evaluateActorFlags({ actorDocument: actor, flagPaths: sourceFlagPaths, scope: 'source', sourceToken: targetToken });
+	evaluateEffects({ effects: actor.appliedEffects, flagPaths: sourceFlagPaths, scope: 'source', sourceToken: targetToken, buildLabel: (effect) => `${effect.name} (${flagName})` });
+
+	const relatedActor = relatedToken?.actor;
+	evaluateActorFlags({ actorDocument: relatedActor, flagPaths: grantsFlagPaths, scope: 'grants', sourceToken: relatedToken });
+	evaluateEffects({ effects: relatedActor?.appliedEffects, flagPaths: grantsFlagPaths, scope: 'grants', sourceToken: relatedToken, buildLabel: (effect) => `${effect.name} (grants.${flagName})` });
+
+	for (const auraToken of canvas?.tokens?.placeables ?? []) {
+		const auraActor = auraToken?.actor;
+		if (!auraActor) continue;
+		evaluateActorFlags({ actorDocument: auraActor, flagPaths: auraFlagPaths, scope: 'aura', sourceToken: auraToken, auraToken });
+		evaluateEffects({
+			effects: auraActor.appliedEffects,
+			flagPaths: auraFlagPaths,
+			scope: 'aura',
+			sourceToken: auraToken,
+			auraToken,
+			buildLabel: (effect) => auraToken?.name ? `${effect.name} - Aura (${auraToken.name}) (${flagName})` : `${effect.name} (aura.${flagName})`,
+		});
 	}
-	if (!labels.length) labels.push(`${_i18nConditions(statusId.capitalize()) || statusId.capitalize()} (${flagName})`);
-	return { suppressed: true, labels: [...new Set(labels)] };
+
+	if (!suppressed) return { suppressed: false, labels: [] };
+	if (!labels.size) labels.add(`${_i18nConditions(statusKey) || statusKey} (${flagName})`);
+	return { suppressed: true, labels: [...labels] };
 }
 
 function automatedItemsTables({ ac5eConfig, subjectToken, opponentToken }) {
diff --git a/wiki/Home.md b/wiki/Home.md
index 9fb667e..cf7b1ab 100644
--- a/wiki/Home.md
+++ b/wiki/Home.md
@@ -6,4 +6,6 @@ Welcome to the Automated Conditions 5e wiki!
 
 #### [Settings walkthrough](<https://github.com/thatlonelybugbear/automated-conditions-5e/wiki/Settings>)
 
-#### [Compatibility with MidiQOL and CPR modules](<https://github.com/thatlonelybugbear/automated-conditions-5e/wiki/Compatibility-with-MidiQOL-and-Cauldron-of-Plentiful-Resources-(CPR)>)
\ No newline at end of file
+#### [Compatibility with MidiQOL and CPR modules](<https://github.com/thatlonelybugbear/automated-conditions-5e/wiki/Compatibility-with-MidiQOL-and-Cauldron-of-Plentiful-Resources-(CPR)>)
+
+#### [Status effects overrides API](<https://github.com/thatlonelybugbear/automated-conditions-5e/wiki/Status-Effects-Overrides-API>)
